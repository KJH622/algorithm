# 대회 or 인턴

- 1팀: 2명의 여학생과 1명의 남학생

- n: 여학생 수

- m: 남학생 수

- k: 인턴쉽에 참여해야 하는 인원

## 풀이 1. 팀을 먼저 만들고 남는 인원으로 k를 감당 (수식형)

### 핵심 아이디어

- 1팀은 여 2 + 남 1 = 3명이 필요하다.

- 먼저 만들 수 있는 팀을 최대한 만든 뒤, 인턴쉽 참여 인원 k명을 이 인원들(팀 외 남는 사람 + 필요하면 팀 해체)에서 충당한다.

### 풀이 (Python)

```
n, m, k = map(int, input().split())

teams = min(n // 2, m)            # 1. 최대 팀 수
leftover = n + m - teams * 3      # 2. 팀 외에 남는 인원 수

if leftover >= k:                  # 3. 남는 인원만으로 인턴 충분
    print(teams)
else:
    need = k - leftover            # 4. 추가로 더 필요한 인턴 수
    reduce = (need + 2) // 3       # 5. 해체해야 할 팀 수 = ceil(need / 3)
    print(max(0, teams - reduce))  # 6. 팀 수는 음수가 되지 않도록
```

### 단계별 설명

**1. 최대 팀 수**

```
teams = min(n // 2, m)
```

- 여학생 2명이 한 팀에 필요하니 **여학생으로 만들 수 있는 최대 팀**은 `n // 2`

- 남학생으로 만들 수 있는 최대 팀은 `m`

- 둘 중 작은 값이 실제 가능한 **최대 팀 수**

**2. 팀 외 남는 인원 수**

```
leftover = n + m - teams * 3
```

- 전체 인원은 `n + m`

- 팀 `teams`개를 만들면 총 `teams * 3` 명이 팀에 묶임

- **팀에 속하지 않은 남는 인원**이 `leftover`이며, 이 인원은 인턴으로 보낼 수 있는 자유 인원이다.

**3. 남는 인원으로 인턴이 충분한가?**

```
if leftover >= k:
    print(teams)
```

- 팀 해체 없이도 인턴 `k`명을 모두 충당 가능 -> **현재 팀 수가 최댓값**

**4. 부족하면 얼마나 더 필요한가**

```
need = k - leftover
```

- 남는 인원으로는 `leftover`명 밖에 못 보내기 때문에 추가로 필요한 인턴쉽에 참여할 인원 수는 `need`

**5. 팀 해체는 몇 팀을 해야 하는가?**

```
reduce = (need + 2) // 3
```

- **팀 하나를 해체하려면 3명(여2+남1)** 을 확보할 수 있음

- `ceil(need/3)` 만큼 팀을 줄여야 함

- 정수 연산으로 올림을 구현: `ceil(a / b) = (a + b - 1) // b

    => 여기서 `b = 3`이므로 `(need + 2) // 3`

**6. 최종 팀 수**

```
print(max(0, teams - reduce))
```

- 해체한 만큼 팀 수 감소

- 최악의 경우 0 미만이 될 수 있으므로 `max(0, ...)`으로 작성

### 예시로 검증

**예시 1**

```
n=6, m=3, k=2
teams = min(6//2, 3) = min(3, 3) = 3
leftover = 6+3 - 3*3 = 9 - 9 = 0
leftover < k → need = 2, reduce = ceil(2/3)=1

정답: teams - reduce = 3 - 1 = 2
```

- 직접 구성해도, 팀 3개 만들면 남는 인원 0명 -> 인턴쉽으로 2명을 보내려면 팀 1개 해체 필요 -> 즉, 팀 2개

**예시 2**

```
n=7, m=5, k=3
teams = min(7//2, 5) = min(3, 5) = 3
leftover = 7+5 - 3*3 = 12 - 9 = 3
leftover >= k → 팀 해체 없이 3명 인턴 가능 → 정답 3
```

**예시 3**

```
n=2, m=1, k=1
teams = min(2//2, 1) = 1
leftover = 2+1 - 1*3 = 0
leftover < k → need=1 → reduce=ceil(1/3)=1 → 정답=0
```

### 왜 "팀을 먼저 최대로 만드는 것'이 최적일까? (직관)

- 팀을 만들 수 있는데 남겨두면, 어차피 인턴을 보내려면 사람을 꺼내야 하므로 손해이다.

- **먼저 최대로 팀을 만든 뒤**, 남는 인원에서 인턴을 보내고, 부족하면 **팀을 해체**하는 것이 항상 최적이다.

- 팀 하나를 해체하면 **정확히 3명**을 확보하므로 "부족분을 3으로 올림 나누기"가 자연스럽게 나온다.

### 복잡도

- **O(1)** : 입력 한 번 읽고 상수 개의 계산만 한다. 매우 빠르다.

### 실수/함정 포인트

- 인턴 `k`가 0일때도 잘 동작한다. (`leftover >= 0`이므로 그대로 `teams` 출력)

- `reduce` 계산에서 올림 나눗셈을 **정확히** 해야 한다: `(need + 2) // 3`

- 최종 `teams - reduce`가 음수로 떨어질 수 있으니 `max(0, ...)`로 안전하게 처리

## 풀이 2. 인턴을 한 명씩 빼면서 손해 최소화 (그리디)

### 핵심 아이디어

- 팀 1개 = **여 2명 + 남 1명 (총 3명)**

- 인턴으로 **k명**을 내보내야 함

- 최종적으로 만들 수 있는 팀 수를 **최대화**해야 함

### 그리디 아이디어

현재 만들 수 있는 팀 수는 `t = min(n // 2, m)`이고, 이 **t를 줄이지 않으려면** "팀 수를 제한하지 않는 쪽(여 2 vs 남 1)에서 먼저" 사람을 빼야 한다.

- 만약 `n // 2 > m`이면, **여학생이 남학생보다 상대적으로 많다**는 뜻 -> 여학생에서 빼는 것이 이득

- 만약 `n // 2 < m`이면, **남학생이 상대적으로 많다**는 뜻 -> 남학생에서 빼는 게 이득

- 만약 `n // 2 == m`이면 둘 다 빡빡한 상태이므로, 

    - n이 홀수이면 여학생을 1명 빼도 `n // 2`가 **유지**될 수 있어 유리함

        (예: n = 5 -> 4로 내려가도 5 // 2 = 2, 4 // 2 = 2)
    
    - 그 외엔 어느 쪽을 빼든 결국 t가 줄어든다. (보통 남에서 빼도 무방)

이렇게 **항상 팀 수를 줄이지 않거나, 줄이더라도 가장 적게 줄이는 선택**을 1명씩 k번 반복하는 게 그리디이다.

### 안정적인 그리디 코드 (한 명씩 최선 선택)

- 아래 코드는 매 차례 "여에서 1명 빼기"와 "남에서 1명 빼기" 두 경우를 **둘 다 가상으로 계산**해보고, 더 많은 팀을 유지하는 쪽을 선택한다. (타이브레이크도 자동 해결)

```
n, m, k = map(int, input().split())

while k > 0 and (n > 0 or m > 0):
    # 후보 1: 여학생 1명 빼보기
    if n > 0:
        t_if_remove_f = min((n - 1) // 2, m)
    else:
        t_if_remove_f = -1  # 불가능 표시

    # 후보 2: 남학생 1명 빼보기
    if m > 0:
        t_if_remove_m = min(n // 2, m - 1)
    else:
        t_if_remove_m = -1  # 불가능 표시

    # 더 큰 팀 수를 남기는 선택을 한다 (동률이면 아무거나)
    if t_if_remove_f >= t_if_remove_m and n > 0:
        n -= 1
    elif m > 0:
        m -= 1
    else:
        break  # 뺄 사람이 없음

    k -= 1

print(min(n // 2, m))
```

**왜 안전한가?**

- 매번 "한 명을 어디서 빼야 최종 팀 수가 더 크냐"를 직접 비교 -> 국소 최선이 전역 최선으로 이어짐

- `n // 2`와 `m`의 **제한 원인**(여 2명, 남 1명) 구조 상, 1명 단위로 선택해도 이 탐욕 규칙이 깨지지 않음

### 가벼운 그리디 (빠른 휴리스틱 + 타이 브레이크)

- 조금 더 빠르고 간단한 버전(직관형)

```
n, m, k = map(int, input().split())

while k > 0 and (n > 0 or m > 0):
    if n // 2 > m:
        # 여학생이 남음: 여학생에서 빼기
        n -= 1
    elif n // 2 < m:
        # 남학생이 남음: 남학생에서 빼기
        m -= 1
    else:
        # n//2 == m (빡빡할 때)
        if n % 2 == 1 and n > 0:
            # 여가 홀수면 여 1명 빼도 n//2 유지 → 이득
            n -= 1
        else:
            # 그 외엔 어느 쪽이나 결국 팀수 줄어듦 → 보통 남에서 빼기
            if m > 0:
                m -= 1
            elif n > 0:
                n -= 1
            else:
                break
    k -= 1

print(min(n // 2, m))
```

- 핵심 타이브레이크: `n // 2 == m`일 때 **n이 홀수이면 여학생을 빼는 게 이득**인 경우가 있음

    (예: n = 5, m = 2, k = 1 -> 여를 빼면 팀 2 유지, 남을 빼면 팀 1로 감소)

### 직관 검증 예시

**예시 1**

- `n = 5, m = 2, k = 1`

    - 시작 t = min(5 // 2, 2) = 2

    - 동률(n // 2 = 2, m = 2)이면서 **n이 홀수** -> 여 1명 빼기: n = 4 -> t = min(2, 2) = 2 (유지)

    - 남 1명 빼면 m = 1 -> t = min(2, 1) = 1 (감소)

    - 즉, 그리디가 여에서 빼는 게 최적

**예시 2**

- `n = 6, m = 3, k = 2`

    - 시작 t = 3, leftover = 0 -> 누굴 빼도 결국 팀이 줄어야 함

    - 한 명씩 최적 선택해도 최종 2팀이 최선

### 복잡도

- 둘 다 `O(k)` (한 명씩 k번 결정)

- 2875의 입력 범위에서 충분히 빠르다.